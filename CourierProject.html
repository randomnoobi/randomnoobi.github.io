<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sam Wang | Game Dev Portfolio</title>

  <!-- Performance: preconnect + single font request -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />

  <link rel="stylesheet" href="style.css" />
  <meta name="description" content="Sam Wang’s game dev log with screenshots, sprite gallery, and code snippets." />
</head>
<body>
  <header class="site-header container">
    <h1>Sam Wang’s Game Dev Log</h1>
    <p>Documenting my journey in making games, art, and more.</p>
  </header>

  <main class="container">
    <!-- Screenshots -->
    <section class="screens">
      <h2>Screenshots</h2>
      <figure>
        <img
          src="Game Example (1).png"
          alt="Screenshot of dialouge with npc"
          loading="lazy"
          width="1280" height="720"
        />
      </figure>
    </section>

    <!-- Sprite Gallery -->
    <section class="gallery sprites">
      <h2>Sprite Assets</h2>
      <div class="grid">
        <!-- Add class="pixel-art" to keep crisp edges -->
        <img src="Courier.gif"   alt="Player animation"      class="sprite-img pixel-art" loading="lazy" width="256" height="256">
      </div>
    </section>

    <!-- Devlog -->
    <section class="log">
      <h2>Devlog</h2>

      <article>
        <h3>11/23/25 Week 1: Planning</h3>
        <p>This week, I mainly focused on figuring out the overall direction of the game. I decided to stick with a pixel-art aesthetic and build it as a 2D platformer, but with a stronger emphasis on fast, fluid movement than anything I’ve made before. The idea I’m settling into is a game where you play as a courier running deliveries through a small frontier village and the surrounding wilderness. As I planned things out, I realized I want the core gameplay to feel really momentum-based—lots of running, jumping, and dashing that all chain smoothly together. I also sketched out how deliveries will work: some will be timed challenges, others will be more puzzle-like, and a few will force the player to navigate tricky terrain or hazards. I wrote down ideas for NPCs around the village that can give different delivery tasks, open shortcuts, or unlock new areas. The more I think about it, the more I like the idea of the world slowly becoming a movement playground as you progress. Overall, most of this week was about refining the concept and getting a clearer picture of what the gameplay loop will look like as I start building it.</p>
      </article>

      <article>
        <h3>12/10/25 Week 2: Art</h3>
        <p>This week I also worked on the player’s animations, which helped define how the character feels in motion. I created a full set of core movement animations: idle, run, jump, and dash. The idle animation keeps the character grounded with a small breathing motion so they don’t feel static. The run animation is snappy and has a clear forward lean, which sells the sense of speed and momentum I want for the game. For the jump animation, I drew a strong upward pose that reads immediately on screen, making it obvious when the player leaves the ground. And finally, the dash animation exaggerates the motion with a stretched silhouette so the burst of speed feels impactful. Having these animations finished makes it much easier to visualize how the character will move through the world, and it’s already helping me fine-tune the game’s feel as I connect the art to the movement system.</p>
      </article>

      <article>
        <h3>12/16/25 Week 3: Tileset</h3>
        <p>This week, I focused on building out the visual environment and finally getting my animations working inside the game. For the tiles, I decided to reuse the tileset from my last project since the style already matched what I wanted for this game. I reorganized the tiles into a proper tileset layout and set up Rule Tiles so Unity could automatically place the correct edges and corners while I painted the level. This made it much faster to block out the terrain and give the game world a consistent look. I also spent time integrating the player animations into the Animator and wiring them up through my movement script. I added transitions for idle, run, jump, fall, and dash, and made sure they react instantly to the player’s movement so everything feels smooth. Getting the animations and movement synced was a big step because it made the character finally feel alive and responsive. Overall, Week 3 was about turning my early art and movement work into something functional and cohesive inside the engine, and seeing everything start to come together visually has been really motivating.</p>
      </article>

      <article>
        <h3>12/26/25 Week 4: Quest</h3>
        <p>This week, I focused on implementing the quest and UI systems and connecting them to the gameplay. I added interactive NPC dialogue that allows the player to accept quests through a multi-line dialogue system. I spent a lot of time debugging input handling to make sure dialogue advances smoothly, closes correctly, and doesn’t immediately reopen. Once that was working, I added a quest tracking system that keeps track of active quests after they are accepted. I designed a simple quest log UI that displays the player’s current quests and made it toggleable with a key press, so it doesn’t clutter the screen during gameplay. By the end of the week, the game had a functioning dialogue system, quest acceptance flow, and quest log UI, which made it feel much more like a complete RPG experience rather than just a movement prototype.</p>
      </article>
      
    </section>

    <!-- Code -->
    <section class="code">
      <h2>Code</h2>
      <details>
        <summary>Dialouge Script</summary>
        <pre><code>
          using System;
using UnityEngine;
using TMPro;

public class DialogueScript : MonoBehaviour
{
    [Header("UI")]
    public GameObject dialoguePanel;   // assign the parent panel GameObject
    public TMP_Text nameText;
    public TMP_Text dialogueText;

    [Header("Optional Prompt UI")]
    public GameObject interactPrompt;

    [Header("Close Lock")]
    public float closeInputLock = 0.15f; // prevents immediate re-open on same E press

    [Header("Open Lock")]
    public float openInputLock = 0.1f;   // prevents instant advance on the same E press used to open
    private float lastOpenTime = -999f;

    private string[] lines;
    private int index;
    private bool dialogueActive = false;

    private Action onDialogueFinished;

    private float lastCloseTime = -999f;

    public bool IsDialogueActive => dialogueActive;
    public bool RecentlyClosed => Time.time < lastCloseTime + closeInputLock;

    void Start()
    {
        if (dialoguePanel != null) dialoguePanel.SetActive(false);
        if (interactPrompt != null) interactPrompt.SetActive(false);
    }

    void Update()
    {
        if (!dialogueActive) return;

        // NEW: ignore E briefly right after opening so it doesn't auto-skip to line 2
        if (Time.time < lastOpenTime + openInputLock) return;

        if (Input.GetKeyDown(KeyCode.E))
        {
            AdvanceOrClose();
        }
    }

    public void StartDialogue(string npcName, string[] dialogueLines, Action finishedCallback)
    {
        if (dialogueLines == null || dialogueLines.Length == 0) return;

        dialogueActive = true;
        lines = dialogueLines;
        index = 0;
        onDialogueFinished = finishedCallback;

        // NEW: record open time so we can block the opening E press from advancing
        lastOpenTime = Time.time;

        if (dialoguePanel != null) dialoguePanel.SetActive(true);
        if (nameText != null) nameText.text = npcName;
        if (dialogueText != null) dialogueText.text = lines[index];

        if (interactPrompt != null) interactPrompt.SetActive(false);
    }

    private void AdvanceOrClose()
    {
        // If currently showing the last line, pressing E accepts/callback then closes
        if (index >= lines.Length - 1)
        {
            onDialogueFinished?.Invoke();
            onDialogueFinished = null;

            CloseDialogue();
            return;
        }

        // Otherwise, go to next line
        index++;
        if (dialogueText != null) dialogueText.text = lines[index];
    }

    public void CloseDialogue()
    {
        dialogueActive = false;
        lastCloseTime = Time.time;

        if (dialoguePanel != null)
            dialoguePanel.SetActive(false);
    }

    public void ShowInteractPrompt(bool show)
    {
        if (interactPrompt != null && !dialogueActive)
            interactPrompt.SetActive(show);
    }
}

        </code></pre>
      </details>
    </section>
  </main>

  <footer class="site-footer container">
    <p>2025 Sam Wang • <a href="https://github.com/randomnoobi" target="_blank" rel="noopener">GitHub</a></p>
  </footer>
</body>
</html>
